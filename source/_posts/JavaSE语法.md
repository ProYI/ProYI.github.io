---
title: JavaSE语法
tags:
  - JavaSE
  - 面试题
categories:
  - 技术
  - Java
  - JavaSE
abbrlink: 188d7817
date: 2018-10-13 00:24:40
permalink:
description:
image:
copyright:
sticky: 
---
<p class="description">JavaSE基础知识整理</p>

<!-- more -->

## 面向对象都有哪些特性以及理解
* 1)`继承`：  
    继承是从已有类得到继承信息创建新类的过程  
    提供继承信息的类被称为`父类（超类、基类）`；  
    得到继承信息的类被称为`子类（派生类）`。  
    继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。
* 2)`封装`：  
    通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。  
    
    面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。  
    我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。  
    
    可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。  
* 3)`多态性`：  
    多态性是指允许不同子类型的对象对同一消息作出不同的响应。  
    简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。  
    
    多态性分为编译时的多态性和运行时的多态性。  
    如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：  
    当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的。
    
    方法重载（overload）实现的是编译时的多态性（也称为前绑定），  
    而方法重写（override）实现的是运行时的多态性（也称为后绑定）。  
    <font color="green">运行时的多态</font>是面向对象最精髓的东西。
    
    要实现多态需要做两件事：
    1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；
    2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 
* 4）`抽象`：  
    抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。  
    抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。  

**注意**：默认情况下面向对象有3大特性，封装、继承、多态，如果问题是4大特性，那么就加上抽象

## JavaSE语法
### 1.Java有没有goto语句？  
goto是Java 中的保留字，在目前版本的Java中没有使用。  
根据James Gosling（Java 之父）编写的《The Java Programming Language》一书的附录中给出了一个 Java 关键字列表，其中有`goto`和`const`，但是这两个是目前无法使用的关键字，因此有些地方将其称之为`保留字`  
其实保留字这个词应该有更广泛的意义，因为熟悉 C 语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字。  
### 2.& 和 && 的区别  
> &运算符有两种用法：  
> > (1)按位与  
> > (2)逻辑与  

> &&运算符是短路与运算。  
`逻辑与`跟`短路与`的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是`true`整个表达式的值才是`true`  

<span style="border-bottom:2px dashed green;">&&之所以称为短路运算是因为，如果&&左边的表达式的值是`false`，右边的表达式会被直接短路掉，不会进行运算。</span>

很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是`null`而且不是`空字符串`，应当写为
```java
username != null && !username.equals("")
```
二者的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的 equals 比较，否则会产生 NullPointerException 异常。  
注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。  
### 3.两个对象值相同 (x.equals(y) == true) ，但却可有不同的hashCode，这句话对不对？  
不对  
如果两个对象 x 和 y 满足 x.equals(y) == true，它们的哈希码（hashCode）应当相同。  

Java 对于eqauls 方法和 hashCode 方法是这样规定的：  
(1)如果两个对象相同（equals 方法返回 true），那么它们的hashCode 值一定要相同；  
(2)如果两个对象的 hashCode 相同，它们并不一定相同。  

当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在`Set集合`中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。  

关于equals 和 hashCode方法，在 Joshua Bloch 的大作《Effective Java》（《Effective Java》、《Java 编程思想》以及《重构：改善既有代码质量》是 Java 程序员必看书籍）中是这样介绍 equals 方法的。  
首先 equals 方法必须满足  
`自反性`（x.equals(x)必须返回 true）、  
`对称性`（x.equals(y)返回 true 时，y.equals(x)也必须返回 true）、  
`传递性`（x.equals(y)和 y.equals(z)都返回 true 时，x.equals(z)也必须返回 true）  
`一致性`（当x和y引用的对象信息没有被修改时，多次调用 x.equals(y)应该得到同样的返回值）  

而且对于任何非 null值的引用x，x.equals(null)必须返回false。  

实现高质量的equals方法的诀窍包括：  
1. 使用==操作符检查"参数是否为这个对象的引用"；  
2. 使用 instanceof 操作符检查"参数是否为正确的类型"；  
3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；  
4. 编写完 equals方法后，问自己它是否满足对称性、传递性、一致性；  
5. 重写 equals 时总是要重写 hashCode；  
6. 不要将 equals方法参数中的 Object 对象替换为其他的类型，在重写时不要忘掉@Override 注解  
### 4.是否可以继承String？  
String类是final类，不可以被继承  
继承 String 本身就是一个错误的行为，对 String 类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）  
### 5.当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？
是`值传递`。  
Java语言的方法调用<span style="border-bottom:2px dashed green;">只支持参数的值传递</span>。  
当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。  
C++和 C#中可以通过传引用或传输出参数来改变传入的参数的值。  
说明：Java中没有传引用实在是非常的不方便，这一点在 Java 8 中仍然没有得到改进，正是如此在 Java 编写的代码中才会出现大量的 Wrapper 类（将需要通过方法调用修改的引用置于一个 Wrapper 类中，再将Wrapper 对象传入方法）  
这样的做法只会让代码变得臃肿，尤其是让从 C 和 C++转型为 Java 程序员的开发者无法容忍  
### 6.重载（overload）和重写（override）的区别？重载的方法能否根据返回类型进行区分？  
方法的重载和重写都是实现多态的方式，区别在于前者实现的是`编译时的多态性`，而后者实现的是`运行时的多态性`。  
重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载  
重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。  
重载对返回类型没有特殊的要求。  

方法重载的规则：   
1. 方法名一致，参数列表中参数的顺序，类型，个数不同  
2. 重载与方法的返回值无关，存在于父类和子类，同类中  
3. 可以抛出不同的异常，可以有不同修饰符  

方法重写的规则：  
1. 参数列表必须完全与被重写方法的一致，返回类型必须完全与被重写方法的返回类型一致   
2. 构造方法不能被重写，声明为final的方法不能被重写，声明为static的方法不能被重写，但是能够被再次声明  
3. 访问权限不能比父类中被重写的方法的访问权限更低  
4. 重写的方法能够抛出任何非强制异常（UncheckedException，也叫非运行时异常），无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以  
### 7.为什么函数不能根据返回类型来区分重载？  
因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。  
例如：  
```java 
float max(int a, int b); 
int max(int a, int b); 
```
当调用max(1, 2);时无法确定调用的是哪个，单从这一点上来说，仅返回值类型不同的重载是不应该允许的  

再比如对下面这两个方法来说，虽然它们有同样的名字和自变量，但其实是很容易区分的： 
```java 
void f() {}  
int f() {}  
```
若编译器可根据上下文（语境）明确判断出含义，比如在 int x=f()中，那么这样做完全没有问题。  
然而，我们也可能调用一个方法，同时忽略返回值，我们通常把这称为“为它的副作用去调用一个方法”，因为我  们关心的不是返回值，而是方法调用的其他效果。  
所以假如我们像下面这样调用方法： f();  
Java 怎样判断f()的具体调用方式呢？而且别人如何识别并理解代码呢？由于存在这一类的问题，所以不能  

函数的返回值只是作为函数运行之后的一个“状态”，它是保持方法的调用者与被调用者进行通信的关键。并不能作为某个方法的“标识”  
### 8.char 型变量中能不能存储一个中文汉字，为什么？  
char 类型可以存储一个中文汉字，因为Java中使用的编码是 Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个 char 类型占 2 个字节（16 比特），所以放一个中文是没问题的。   
**补充**：  
使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是 Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。  
所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如 InputStreamReader 和 OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务  
对于C程序员来说，要完成这样的编码转换恐怕要依赖于 union（联合体/共用体）共享内存的特征来实现了。
### 9.抽象类(abstract class)和接口(interface)有什么异同？  
> 不同： 
> > 抽象类：  
    1.抽象类中可以定义构造器  
    2.可以有抽象方法和具体方法  
    3.接口中的成员全都是public的  
    4.抽象类中可以定义成员变量   
    5.有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法  
    6.抽象类中可以包含静态方法  
    7.一个类只能继承一个抽象类  
> > 接口：  
    1.接口中不能定义构造器  
    2.方法全部都是抽象方法  
    3.抽象类中的成员可以是 private、默认、protected、public  
    4.接口中定义的成员变量实际上都是常量  
    5.接口中不能有静态方法  
    6.一个类可以实现多个接口     

> 相同：  
    1.不能够实例化  
    2.可以将抽象类和接口类型作为引用类型   
    3.一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类  
### 10.抽象的(abstract)方法是否可同时是静态的(static), 是否可同时是本地方法(native)，是否可同时被synchronized？  
`都不能`。  
抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。  
本地方法是由 本地代码（如 C 代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。  
synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。  
### 11.阐述静态变量和实例变量的区别？  
**静态变量**: 是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不
管创建多少个对象，静态变量在内存中有且仅有一个拷贝  
**实例变量**: 必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。  
静态变量可以实现让多个对象共享内存。  
### 12.==和equals的区别？  
equals和== 最大的区别是一个是`方法`一个是`运算符`。    
==：  
> 如果比较的对象是`基本数据类型`，则比较的是数值是否相等   
> 如果比较的是`引用数据类型`，则比较的是对象的地址值是否相等  

equals()：用来比较方法两个对象的内容是否相等  
注意：  
equals方法不能用于基本数据类型的变量，如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的`地址`。
### 13.break和continue的区别？  
break和continue都是用来控制循环的语句。   
break用于完全结束一个循环，跳出循环体执行循环后面的语句。   
continue用于跳过本次循环，执行下次循环。  
### 14.String s = "Hello";s = s + " world!";这两行代码执行后，原始的String对象中的内容到底变了没有？  
`没有`  
因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。  

在这段代码中，s原先指向一个String对象，内容是 "Hello"，然后我们对s进行了“+”操作，那么s所指向的那个对象是否发生了改变呢？  
答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为"Hello world!"，<span style="border-bottom:2px dashed green;">原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。</span>  

通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用String来代表字符串的话会引起很大的内存开销。  

因为 <span style="border-bottom:2px dashed red;">String对象建立之后不能再改变</span>，所以对于每一个不同的字符串，都需要一个String对象来表示。  
这时，应该考虑使用StringBuffer类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。  

同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都new一个String。  
例如我们要在构造器中对一个名叫s的String引用变量进行初始化，把它设置为初始值，应当这样做： 
```java
public class Demo { 
    private String s; 
    ... 
    s = "Initial Value"; 
    ... 
} 
而非 
s = new String("Initial Value");     
```
后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为String对象不可改变，所以对于内容相同的字符串，只要一个String对象来表示就可以了。  
也就说，多次调用上面的构造器创建多个对象，他们的String类型属性s都指向同一个对象。  

上面的结论还基于这样一个事实：  
对于字符串常量，如果内容相同，Java认为它们代表同一个String对象。  
而用关键字`new`调用构造器，总是会创建一个新的对象，`无论内容是否相同`。  

至于为什么要把String类设计成不可变类，是它的用途决定的。  
其实不只String，很多Java标准类库中的类都是不可变的。  

在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。  
不可变类有一些优点，比如因为它的对象是只读的，所以`多线程并发`访问也不会有任何问题。  

当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以Java标准类库还提供了一个可变版本，即 StringBuffer。  